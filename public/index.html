<html>
  <script src="./jquery-1.11.0.min.js"></script>
  <script src="./three.min.js"></script>
  <script src="socket.io/socket.io.js"></script>
  <script src="https://www.google.com/jsapi"></script>
  <body style="width: 100%; height: 100%; margin: 0px;">
    <div id="stage" width="100%" height="100%"></div>
    <div id="queryEditor" style="padding:0.2em; position:fixed; left:1em; top:1em; background-color:#333333">
      <input type="text" id="query1" placeholder="first query" value="space"><br>
      <input type="text" id="query2" placeholder="second query" value="nature"><br>
      <button id="searchButton">Go</button>
    </div>
  </body>
  <script id="vertexShader" type="x-shader/x-vertex">
/* Vertex shader */
precision highp float;
precision highp int;

uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;

void main() {
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">
/* Fragment shader */
precision highp float;
precision highp int;

// 32 samplers is actually the max number of samplers in any glsl program.
// 31 is our max here, since one other sampler is used for the superTile
#define MAX_NUM_IMAGES 31

uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;

uniform int numSubImages;

uniform sampler2D superTileTexture;
uniform sampler2D subTileTextures[MAX_NUM_IMAGES];

uniform vec3 subTileAverages[MAX_NUM_IMAGES];

uniform float zoom;
uniform float zoomMax;
uniform vec2 zoomPosition;

void main() {
  const vec2 TILE_SIZE = vec2(0.01, 0.01); 
  float zoomPoly = 1.;//zoom * zoom * zoom; // level of zoom 
  vec2 nPos = gl_FragCoord.xy / resolution.xy; // coordinate of fragment from (0,0) to (1,1), wrt entire renderable area
  vec2 zPos = vec2(nPos.x, nPos.y) / zoomPoly + zoomPosition; // coordinate of the fragment in the zoomed space

  vec2 tile = vec2(floor(zPos.x / TILE_SIZE.x), floor(zPos.y / TILE_SIZE.y)); // the tile this fragment resides in (eg (0,0), (1,4), etc...)
  vec2 tPos = zPos / TILE_SIZE - tile; // the location of the fragment wrt its tile

  // calculate average color of the super image in the tile's region
  vec4 sum = vec4(0.);
  const int PIXEL_SAMPLES = 10;
  for (int i = 0; i < PIXEL_SAMPLES; i++) {
    for (int j = 0; j < PIXEL_SAMPLES; j++) {
      vec2 tileTopLeft = tile * TILE_SIZE;
      vec2 ijPercent = vec2(float(i) / float(PIXEL_SAMPLES), float(j) / float(PIXEL_SAMPLES));
      sum += texture2D(superTileTexture, tileTopLeft + ijPercent * TILE_SIZE);
    }
  }
  vec4 average = sum / float(PIXEL_SAMPLES * PIXEL_SAMPLES);

  // find the subtile texture with the closest average
  int closestIndex = -1;
  float closestDist = 9999999999.;
  for (int ti = 0; ti < MAX_NUM_IMAGES; ti++) {
    // for loops in glsl can't use non-const compares
    if (ti >= numSubImages) {
      break;
    }

    float newDist = distance(average.rgb, subTileAverages[ti].rgb);
    if (newDist < closestDist) {
      closestDist = newDist;
      closestIndex = ti;
    }
  }

  vec4 bigTilePixel = texture2D(superTileTexture, zPos);
  vec4 smallTilePixel = vec4(0.);
  // TODO: workaround. We cannot use nonconst vars as texture index, so we do this instead:
  for (int i = 0; i < MAX_NUM_IMAGES; i++) if (i == closestIndex) smallTilePixel = texture2D(subTileTextures[i], tPos);

  float zoomFactor = (zoom - 1.) / (zoomMax - 1.);
  gl_FragColor = mix(bigTilePixel, 
                     smallTilePixel,
                     smoothstep(-0.1, 1.1, (zoom-1.)/(zoomMax-1.)));

  // encode next supertile index in the bottommost row
  if (gl_FragCoord.y == 0.5) {
    gl_FragColor = vec4(float(closestIndex) / float(numSubImages), 1., 1., 1.);
  }
}
  </script>

  <script>
    $('#searchButton').click(function() {
      console.log($('#query1').val(), $('#query2').val());
      var q1 = $('#query1').val(), q2 = $('#query2').val();
      if (q1.length > 0 && q2.length > 0) {
        window.location = '?q1=' + q1 + '&q2=' + q2;
      }
    });

    $('#query1').on('input', function() {
      if ($('#query1').val().length == 0) {
        $('#searchButton').attr('disabled', 'disabled');
      }
      else if ($('#query2').val().length > 0) {
        $('#searchButton').removeAttr('disabled');
      }
    });
    $('#query2').on('input', function() {
      if ($('#query2').val().length == 0) {
        $('#searchButton').attr('disabled', 'disabled');
      }
      else if ($('#query1').val().length > 0) {
        $('#searchButton').removeAttr('disabled');
      }
    });

    function flatten(arr) {
      return arr.reduce(function(a, b) {
        return a.concat(b);
      });
    }

    // start the mosaic once the reuploaded images are ready
    $(document).on('allImagesReady', function(e, queries, successfulReuploads) {
      for (var i = 0; i < queries.length; i++) {
        if (successfulReuploads[i].length == 0) {
          alert('Not enough images were found for query "' + queries[i] + '"');
          return;
        }
      }

      console.log('starting mosaic', queries, successfulReuploads);
      // -- graphics code --
      // -- set up --
      var scene = new THREE.Scene();
      var camera = undefined; 
      var renderer = new THREE.WebGLRenderer({antialias: true});
      var timeStarted = new Date();

      function TileData() {
        this.textures = undefined;
        this.averages = [];
      }
      var superTileData = new TileData();
      var subTileData = new TileData();

      // -- initialize basic uniforms --
      var uniforms = {
          time: {type: 'f', value: 0},
          mouse: {type: 'v2', value: new THREE.Vector2(0, 0)},
          resolution: {type: 'v2', value: new THREE.Vector2(0, 0)},

          zoom: {type: 'f', value: 1},
          zoomMax: {type: 'f', value: 2.7}, 
          zoomPosition: {type: 'v2', value: new THREE.Vector2(0, 0)},
      };

      // image loading and preprocessing
      // placeholder values until we calculate actual averages
      for (var i = 0; i < successfulReuploads[0].length; i++) {
        superTileData.averages.push([0.5, 0.5, 0.5]);
      }
      for (var i = 0; i < successfulReuploads[1].length; i++) {
        subTileData.averages.push([0.5, 0.5, 0.5]);
      }

      // load the reuploaded images and calculate average color
      for (var queryIndex = 0; queryIndex < queries.length; queryIndex++) {
        var query = queries[queryIndex];
        var textures = [];

        // load images
        for (var i = 0; i < successfulReuploads[queryIndex].length; i++) {
          var textureIndex = successfulReuploads[queryIndex][i];
          var url = 'reup/' + query + '/' + textureIndex;
          // get texture (sync)
          var texture = new THREE.ImageUtils.loadTexture(url);
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          textures.push(texture);

          // from http://stackoverflow.com/questions/2541481/get-average-color-of-image-via-javascript
          function getAverageRGB(imgEl) {
            var blockSize = 5, // only visit every 5 pixels
              defaultRGB = {r:0,g:0,b:0}, // for non-supporting envs
              canvas = document.createElement('canvas'),
              context = canvas.getContext && canvas.getContext('2d'),
              data, width, height,
              i = -4,
              length,
              rgb = {r:0,g:0,b:0},
              count = 0;
  
            if (!context) {
              return defaultRGB;
            }

            height = canvas.height = imgEl.naturalHeight || imgEl.offsetHeight || imgEl.height;
            width = canvas.width = imgEl.naturalWidth || imgEl.offsetWidth || imgEl.width;

            context.drawImage(imgEl, 0, 0);

            try {
              data = context.getImageData(0, 0, width, height);
            } catch(e) {
              /* security error, img on diff domain */
              return defaultRGB;
            }

            length = data.data.length;

            while ( (i += blockSize * 4) < length ) {
              ++count;
              rgb.r += data.data[i];
              rgb.g += data.data[i+1];
              rgb.b += data.data[i+2];
            }

            // ~~ used to floor values
            rgb.r = ~~(rgb.r/count);
            rgb.g = ~~(rgb.g/count);
            rgb.b = ~~(rgb.b/count);

            return rgb;
          }

          // calculate average color (async)
          (function(i, queryIndex, img) {
            img.src = url;
            img.onload = function() {
              var averageRGB = getAverageRGB(this);
              var average = [averageRGB.r / 255.0, averageRGB.g / 255.0, averageRGB.b / 255.0];

              if (queryIndex == 0) {
                superTileData.averages[i] = average;
              }
              else if (queryIndex == 1) {
                subTileData.averages[i] = average;
              }
              console.log(superTileData.averages);
            }
          })(i, queryIndex, new Image());
        }
        if (queryIndex == 0) {
          superTileData.textures = textures;
        }
        else if (queryIndex == 1) {
          subTileData.textures = textures;
        }
      } 

      // create uniforms for the textures
      uniforms.superTileTexture = {type: 't', value: superTileData.textures[0]};
      uniforms.subTileTextures = {type: 'tv', value: subTileData.textures};
      uniforms.subTileAverages = {type: 'fv', value: flatten(subTileData.averages)};
      uniforms.numSubImages = {type: 'i', value: subTileData.textures.length};

      console.log(superTileData.textures.length, subTileData.textures.length);

      $('#stage').append(renderer.domElement);

      // make the canvas always cover the entire screen
      window.onresize = function() {
        var width = window.innerWidth;
        var height = window.innerHeight;
        var viewingAngle = 70;
        var aspectRatio = width / height;
        var near = 0.1, far = 2000;
        renderer.setSize(width, height);
        $(renderer.domElement).attr('width', width);
        $(renderer.domElement).attr('height', height);
        camera = new THREE.PerspectiveCamera(viewingAngle, aspectRatio, near, far);
        uniforms.resolution.value.set(width, height);

        scene.add(camera);
        camera.position.set(0, 0, 0);
        camera.lookAt(scene.position);
      }
      window.onresize();

      // -- initialize quad --
      var shaderMaterial = new THREE.ShaderMaterial({
        vertexShader: $('#vertexShader').get(0).textContent,
        fragmentShader: $('#fragmentShader').get(0).textContent,
        uniforms: uniforms,
      });
      var planeGeometry = new THREE.PlaneGeometry(50, 50, 50, 50);
      var plane = new THREE.Mesh(planeGeometry, shaderMaterial);
      plane.position.set(0, 0, -1);
      scene.add(plane);

      // -- mouse tracking -- TODO unused at the moment
      $('body').mousemove(function(event) {
        uniforms.mouse.value.set(event.clientX, window.innerHeight - event.clientY /* flip y */);
      });

      // -- begin rendering --
      function render() {
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        function update() {
          var prevTimeElapsed = uniforms.time.value;
          var timeElapsed = (new Date()) - timeStarted;
          var dt = timeElapsed - prevTimeElapsed;
          uniforms.time.value = timeElapsed;

          var ZOOM_MAX = uniforms.zoomMax.value;
          uniforms.zoom.value = uniforms.zoom.value + dt / 2000;
          if (uniforms.zoom.value > ZOOM_MAX) {
            // reset zoom and switch the sub/super tilesets
            uniforms.zoom.value = uniforms.zoom.value % ZOOM_MAX + 1.0;

            var tmp = superTileData;
            superTileData = subTileData;
            subTileData = tmp;

            // the bottom left pixel's r value encodes the new super tile texture index.
            // we need to retrieve it and modify our uniforms to reflect the change
            var canvas = document.createElement('canvas');
            canvas.width = renderer.domElement.width;
            canvas.height = renderer.domElement.height;
            var context = canvas.getContext('2d');
            context.drawImage(renderer.domElement, 0, 0);
            var pixelData = context.getImageData(0, renderer.domElement.height-1, 1, 1).data;
            var newSuperTileIndex = Math.floor(pixelData[0] / 255 * superTileData.textures.length + 0.5); 

            uniforms.superTileTexture.value = superTileData.textures[newSuperTileIndex];
            uniforms.subTileTextures.value = subTileData.textures;
            uniforms.subTileAverages.value = flatten(subTileData.averages);

            uniforms.numSubImages.value = subTileData.textures.length;
          }
          var zoomPos = 0;
          uniforms.zoomPosition.value = new THREE.Vector2(zoomPos, zoomPos);
        }
        update();
      }
      render();
    })
  </script>
  <script>
    // -- google image crawler --

    // gets image urls from google images and stores them in stack
    // google.load() needs to first be called before calling this
    var getGISURLS = function(stack, query, numImages, callback) {
      var MAX_IMAGES_PER_PAGE = 8; // api's max results per page is 8
      var gis = google.search.ImageSearch;
      var imageSearch = new google.search.ImageSearch();
      imageSearch.setRestriction(gis.RESTRICT_IMAGESIZE,
                                 gis.IMAGESIZE_MEDIUM);
      imageSearch.setResultSetSize(Math.min(MAX_IMAGES_PER_PAGE, numImages));
      imageSearch.setSearchCompleteCallback(null, function(query, callback) {
        for (var i = 0; 
             stack.length < numImages && i < MAX_IMAGES_PER_PAGE; 
             i++) {
          if (imageSearch.results[i]) {
            // note: .url fetches the image from some website and sometimes
            // redirects to an html page instead of an image...
            // use .tbUrl (low-res version hosted by google) for consistency.
            // TODO: find a way to handle .url weirdness
            stack.push(imageSearch.results[i].tbUrl);
          }
        }

        if (stack.length >= numImages) {
          callback();
        }
        else { // turn page if we have yet to get enough images
          var cursor = imageSearch.cursor;
          if (cursor) {
            var numPagesAvailable = cursor.pages.length;
            console.log('turn pg', cursor.currentPageIndex+1, '/', numPagesAvailable);
            if (cursor.currentPageIndex+1 < numPagesAvailable) {
              imageSearch.gotoPage(cursor.currentPageIndex+1);
            }
            else {
              alert('not enough pages');
            }
          }
          else callback();
        }
      }, [query, callback]);
      imageSearch.execute(query);
    };


    // from http://stackoverflow.com/questions/1403888/get-escaped-url-parameter
    function getURLParameter(name) {
      var ret = decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
      );
      if (ret == 'null') return undefined;
      else return ret;
    }

    // get images
    var staticFolder = getURLParameter('staticFolder') || undefined;
    if (staticFolder) {
      var query1 = staticFolder;
      var query2 = staticFolder;
    }
    else {
      var query1 = getURLParameter('q1') || 'space';
      var query2 = getURLParameter('q2') || 'nature';
    }

    $('#query1').val(query1);
    $('#query2').val(query2);
    var queries = [query1, query2];

    // "offline" version. get images from specified directory instead of through node server + google
    if (staticFolder) {
      console.log('using static folder');
      $('#queryEditor').hide();
      var successfulReuploads = [];
      for (var i = 0; i < 31; i++) {
        successfulReuploads.push(i);
      }
      $(document).trigger('allImagesReady', [queries, [successfulReuploads, successfulReuploads]]); 
    }
    else {
      console.log('begin gis search...', queries);
      var downloadStack = [];
      var numImages = 9; // any changes to this need to be reflected in the shader
      var queryStacks = [[], []];
      google.load('search', '1');
      google.setOnLoadCallback(function() {
        getGISURLS(queryStacks[0], queries[0], numImages, function() {
          getGISURLS(queryStacks[1], queries[1], numImages, function() {
            // once we have our urls, send them to the server for rehosting
            var socket = io.connect('/', {reconnect: false});
            socket.emit('reuploadRequest', queries, queryStacks);
  
            console.log('waiting for reply from server...');
            // once the server tells us it has finished...
            socket.on('reuploadComplete', function(successfulReuploads) {
              $(document).trigger('allImagesReady', [queries, successfulReuploads]);
            });
          });
        });
      });
    }
/*
    google.load('search', '1');
    google.setOnLoadCallback(function() {
      for (var qIndex = 0; qIndex < queries.length; qIndex++) {
        var query = queries[qIndex];
        var gis = google.search.ImageSearch;
        var colors = [gis.COLOR_BLACK, 
                      gis.COLOR_BLUE,
                      gis.COLOR_BROWN,
                      gis.COLOR_GRAY,
                      gis.COLOR_GREEN,
                      gis.COLOR_ORANGE,
                      gis.COLOR_PINK,
                      gis.COLOR_PURPLE,
                      gis.COLOR_RED,
                      gis.COLOR_TEAL,
                      gis.COLOR_WHITE,
                      gis.COLOR_YELLOW];
        images[query] = {};
        function search(queries, queryIndex, colors, colorIndex) {
          var imageSearch = new google.search.ImageSearch();
          var color = colors[colorIndex];
          console.log(color);
          imageSearch.setRestriction(gis.RESTRICT_IMAGESIZE,
                                    gis.IMAGESIZE_MEDIUM);
          imageSearch.setRestriction(gis.RESTRICT_COLORFILTER, color);
          imageSearch.setResultSetSize(1);
          imageSearch.setSearchCompleteCallback(this, function (color, query, qIndex, images) {
            if (imageSearch.results && imageSearch.results.length > 0) {
              var results = imageSearch.results;
              for (var i = 0; i < results.length; i++) {
                $('body').append('<img src="' + results[i].tbUrl + '"></img>');
                console.log(color, results[i].tbUrl);
                images[query][color] = results[i].tbUrl;
              }
            }
  
            if (colorIndex + 1 < colors.length) {
              search(queries, queryIndex, colors, colorIndex + 1);
            }
            else if (qIndex + 1 == queries.length) { // if each color + each query has completed
              $(document).trigger('allImagesRetrieved', images);
            }
          }, [color, query, qIndex, images]);
          imageSearch.execute(query);
        }
        search(colors, 0);
      }
    });*/
  </script>
</html>
