<html>
  <script src="./jquery-1.11.0.min.js"></script>
  <script src="./three.min.js"></script>
  <script src="socket.io/socket.io.js"></script>
  <script src="https://www.google.com/jsapi"></script>
  <body style="width:100%; height:100%; margin:0px;">
    <!-- dom elements for webcam texture -->
    <video id="monitor" autoplay width="160" height="120" style="visibility:hidden; position:absolute"></video>
    <canvas id="videoImage" width="160" height="120" style="visibility:hidden; position:absolute"></canvas> 

    <div id="stage" hidden width="100%" height="100%"></div>
    <div id="queryEditor" style="padding:0.2em; position:fixed; left:1em; top:1em; background-color:#333333">
      <input type="text" id="query1" placeholder="first query" value="space"><br>
      <input type="text" id="query2" placeholder="second query" value="nature"><br>
      <button id="searchButton">Go</button>
    </div>
    <img id="spinner" src="./spinner.gif" style="background:#ffffff; background-size:100% 100%; position:absolute; left:50%; top:50%;"></img>
  </body>
  <script id="vertexShader" type="x-shader/x-vertex">
/* Vertex shader */
precision highp float;
precision highp int;

uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;

void main() {
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">


/* Fragment shader */
precision highp float;
precision highp int;

// changes to these defines need to be reflected in the js code and vice versa
#define ATLAS_WIDTH 4096.0 // these two should be powers of two, for compat. with older gpus
#define ATLAS_HEIGHT 4096.0
#define ATLAS_SUB_WIDTH 512.0
#define ATLAS_SUB_HEIGHT 512.0
#define MAX_NUM_IMAGES (int((ATLAS_WIDTH * ATLAS_HEIGHT) / (ATLAS_SUB_WIDTH * ATLAS_SUB_HEIGHT)))

uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;

uniform int numSubImages;

uniform sampler2D superTileTexture;
uniform sampler2D subTileAtlas;

uniform vec3 subTileAverages[MAX_NUM_IMAGES];

uniform float zoom;
uniform float zoomMax;
uniform vec2 zoomPosition;

// Returns the texture coordinates of a tile (specified by index) from the texture atlas.
// tPos is the relative tile position (between (0, 0) and (1, 1))
vec2 getAtlasCoord(int index, vec2 tPos) {
  // this gets the starting _pixel_ of the correct tile in the mosaic
  vec2 atlasCoord = vec2(
    mod(float(index) * ATLAS_SUB_WIDTH, ATLAS_WIDTH),
    floor(float(index) * ATLAS_SUB_WIDTH / ATLAS_WIDTH) * ATLAS_SUB_HEIGHT
  );

  // this scales the correct starting pixel to the correct starting texture coord
  // we do some flipping on the y axis, since html5 canvas defines (0, 0) as the 
  // upper-left corner, while glsl defines (0, 0) as lower-left corner
  atlasCoord.x = atlasCoord.x / ATLAS_WIDTH;
  atlasCoord.y = 1. - (atlasCoord.y / ATLAS_HEIGHT);

  // apply the relative tile position to get the actual texture coordinate
  atlasCoord.x += tPos.x / 8.;
  atlasCoord.y -= (1. - tPos.y) / 8.;

  return atlasCoord;
}

void main() {
  const vec2 TILE_SIZE = vec2(0.02, 0.02); 
  float zoomPoly = 1.;//zoom * zoom * zoom; // level of zoom 
  vec2 nPos = gl_FragCoord.xy / resolution.xy; // coordinate of fragment from (0,0) to (1,1), wrt entire renderable area
  vec2 zPos = vec2(nPos.x, nPos.y) / zoomPoly + zoomPosition; // coordinate of the fragment in the zoomed space

  vec2 tile = vec2(floor(zPos.x / TILE_SIZE.x), floor(zPos.y / TILE_SIZE.y)); // the tile this fragment resides in (eg (0,0), (1,4), etc...)
  vec2 tPos = zPos / TILE_SIZE - tile; // relative tile position (between (0, 0) and (1, 1))

  // calculate average color of the super image in the tile's region
  vec4 sum = vec4(0.);
  const int PIXEL_SAMPLES = 10;
  for (int i = 0; i < PIXEL_SAMPLES; i++) {
    for (int j = 0; j < PIXEL_SAMPLES; j++) {
      vec2 tileTopLeft = tile * TILE_SIZE;
      vec2 ijPercent = vec2(float(i) / float(PIXEL_SAMPLES), float(j) / float(PIXEL_SAMPLES));
      sum += texture2D(superTileTexture, tileTopLeft + ijPercent * TILE_SIZE);
    }
  }
  vec4 average = sum / float(PIXEL_SAMPLES * PIXEL_SAMPLES);

  // find the subtile texture with the closest average
  int closestIndex = -1;
  float closestDist = 9999999999.;
  for (int ti = 0; ti < MAX_NUM_IMAGES; ti++) {
    // for loops in glsl can't use non-const compares
    if (ti >= numSubImages) {
      break;
    }

    float newDist = distance(average.rgb, subTileAverages[ti].rgb);
    if (newDist < closestDist) {
      closestDist = newDist;
      closestIndex = ti;
    }
  }

  vec4 bigTilePixel = texture2D(superTileTexture, zPos);
  vec4 smallTilePixel = vec4(0.);


  vec2 atlasCoord = getAtlasCoord(closestIndex, tPos);
  smallTilePixel = texture2D(subTileAtlas, atlasCoord);
  smallTilePixel = mix(smallTilePixel, average, 0.5); // experimental: tint the pixel by the average

  float zoomFactor = (zoom - 1.) / (zoomMax - 1.);
  gl_FragColor = mix(bigTilePixel, 
                     smallTilePixel,
                     smoothstep(-0.1, 1.1, (zoom-1.)/(zoomMax-1.)));

  // encode next supertile index in the bottommost row
  if (gl_FragCoord.y == 0.5) {
    gl_FragColor = vec4(float(closestIndex) / float(numSubImages), 1., 1., 1.);
  }
}
  </script>
  <script>
    $('#searchButton').click(function() {
      console.log($('#query1').val(), $('#query2').val());
      var q1 = $('#query1').val(), q2 = $('#query2').val();
      if (q1.length > 0 && q2.length > 0) {
        window.location = '?q1=' + q1 + '&q2=' + q2;
      }
    });

    $('#query1').on('input', function() {
      if ($('#query1').val().length == 0) {
        $('#searchButton').attr('disabled', 'disabled');
      }
      else if ($('#query2').val().length > 0) {
        $('#searchButton').removeAttr('disabled');
      }
    });
    $('#query2').on('input', function() {
      if ($('#query2').val().length == 0) {
        $('#searchButton').attr('disabled', 'disabled');
      }
      else if ($('#query1').val().length > 0) {
        $('#searchButton').removeAttr('disabled');
      }
    });

    function flatten(arr) {
      return arr.reduce(function(a, b) {
        return a.concat(b);
      });
    }

    // start the mosaic once the reuploaded images are ready
    $(document).on('allImagesReady', function(e, queries, successfulReuploads, useCamera) {
      for (var i = 0; i < queries.length; i++) {
        if (successfulReuploads[i].length == 0) {
          alert('Not enough images were found for query "' + queries[i] + '"');
          return;
        }
      }

      console.log('starting mosaic', queries, successfulReuploads);
      // -- graphics code --
      // -- set up --
      try {
        var scene = new THREE.Scene();
        var camera = undefined; 
        var renderer = new THREE.WebGLRenderer({antialias: true});
        // webcam vars
        var video, videoTexture, videoImage, videoImageContext, webcamReady = false;
      } catch(e) {
        alert('There was a problem creating the webgl context.');
      }
      var timeStarted = new Date();

      function TileData() {
        this.textures = undefined;
        this.averages = [];
        this.atlas = undefined; // one big texture containing all textures
      }
      var superTileData = new TileData();
      var subTileData = new TileData();
      var ATLAS_WIDTH = 4096, ATLAS_HEIGHT = 4096;
      var ATLAS_SUB_WIDTH = 512, ATLAS_SUB_HEIGHT = 512;

      // -- initialize basic uniforms --
      var uniforms = {
          time: {type: 'f', value: 0},
          mouse: {type: 'v2', value: new THREE.Vector2(0, 0)},
          resolution: {type: 'v2', value: new THREE.Vector2(0, 0)},

          zoom: {type: 'f', value: 1},
          zoomMax: {type: 'f', value: 2.7}, 
          zoomPosition: {type: 'v2', value: new THREE.Vector2(0, 0)},
      };

      // placeholder values until we calculate actual averages
      for (var i = 0; i < successfulReuploads[0].length; i++) {
        superTileData.averages.push([0.5, 0.5, 0.5]);
      }
      for (var i = 0; i < successfulReuploads[1].length; i++) {
        subTileData.averages.push([0.5, 0.5, 0.5]);
      }

      // load the reuploaded images and calculate average color
      var imagesLeft = 0; // number of images we have left to load
      for (var queryIndex = 0; queryIndex < queries.length; queryIndex++) {
        imagesLeft += successfulReuploads[queryIndex].length;
      }

      for (var queryIndex = 0; queryIndex < queries.length; queryIndex++) {
        var query = queries[queryIndex];
        var textures = [];

        // load images
        for (var i = 0; i < successfulReuploads[queryIndex].length; i++) {
          var textureIndex = successfulReuploads[queryIndex][i];
          var url = 'reup/' + query + '/' + textureIndex;
          // get texture (async)
          var texture = new THREE.ImageUtils.loadTexture(url, undefined, function() {
            // on loaded: 
            imagesLeft--;
            if (imagesLeft == 0) {
              preprocessTiles([superTileData, subTileData]);
            }
          });
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          textures.push(texture);
        }
        if (queryIndex == 0) {
          superTileData.textures = textures;
        }
        else if (queryIndex == 1) {
          subTileData.textures = textures;
        }
      } 

      function preprocessTiles(tileDatas) {

        // modified from http://stackoverflow.com/questions/2541481/get-average-color-of-image-via-javascript
        function getAverageRGB(texture) {
          var average = [0.5, 0.5, 0.5];
          var canvas = document.createElement('canvas');
          var context = canvas.getContext('2d');
          var data = undefined;
          var blockSize = 5; // sample every X pixels
          var count = 0;

          canvas.width = texture.image.width;
          canvas.height = texture.image.height;
          context.drawImage(texture.image, 0, 0);
          data = context.getImageData(0, 0, canvas.width, canvas.height);

          for (var i = 0; (i + blockSize * 4) < data.data.length; i += blockSize * 4) {
            average[0] += data.data[i];
            average[1] += data.data[i+1];
            average[2] += data.data[i+2];
            count++;
          }

          average[0] = Math.floor(average[0] / count) / 255.0;
          average[1] = Math.floor(average[1] / count) / 255.0;
          average[2] = Math.floor(average[2] / count) / 255.0;

          return average;
        }

        function generateAtlas(textures, atlasWidth, atlasHeight, subWidth, subHeight) {
          var tilesPerRow = Math.floor(atlasWidth / subWidth);
          var tilesPerColumn = Math.floor(atlasWidth / subHeight);
          if (atlasWidth % subWidth != 0 || atlasHeight % subHeight != 0) {
            console.warn('Atlas size does not evenly divide into subsize');
          }
          if (textures.length > tilesPerRow * tilesPerColumn) {
            throw new Error('Atlas is too small to hold the given textures');
          }

          var canvas = document.createElement('canvas');
          var context = canvas.getContext('2d');
          canvas.width = atlasHeight; 
          canvas.height = atlasWidth;

          for (var i = 0; i < textures.length; i++) {
            var tileX = (i * subWidth) % atlasWidth;
            var tileY = Math.floor((i * subWidth) / atlasWidth) * subHeight;
            context.drawImage(textures[i].image, tileX, tileY, subWidth, subHeight);
          }

          var ret = new THREE.Texture(canvas);
          ret.wrapS = ret.wrapT = THREE.RepeatWrapping;
          return ret;
        }

        for (var tileDataIndex = 0; tileDataIndex < tileDatas.length; tileDataIndex++) {
          var tileData = tileDatas[tileDataIndex];
          for (var i = 0; i < tileData.textures.length; i++) {
            tileData.averages[i] = getAverageRGB(tileData.textures[i]);
          }
          tileData.atlas = generateAtlas(tileData.textures, ATLAS_WIDTH, ATLAS_HEIGHT, ATLAS_SUB_WIDTH, ATLAS_SUB_HEIGHT);
          tileData.atlas.needsUpdate = true;
        }
        $('#spinner').hide();
        $('#stage').show();
        uniforms.superTileTexture.value = superTileData.textures[0];
        uniforms.subTileAtlas.value = subTileData.atlas;
        uniforms.subTileAverages.value = flatten(subTileData.averages);
        uniforms.numSubImages.value = subTileData.textures.length;

      }

      // begin webcam code
      // bits of code here from http://stemkoski.github.io/Three.js/Webcam-Texture.html
      if (useCamera) {
        // initialize camera
        navigator.getUserMedia = navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        window.URL = window.URL || window.webkitURL;

        var camVideo = $('#monitor')[0];
        if (!navigator.getUserMedia) {
          alert('Your browser does not have webcam support');
        }
        else {
          navigator.getUserMedia({video: true}, 
          function(stream) { // on success (user clicks 'allow')
            if (window.URL) {
              camVideo.src = window.URL.createObjectURL(stream);
            }
            else { // Opera
              camVideo.src = stream;
            }
            camVideo.onerror = function(error) {
              stream.stop();
            }
            webcamReady = true;
          },
          function(error) { // on failure
            alert('webcam error:', error);
          });
        }

        // get cam texture
        video = document.getElementById('monitor');
    
        videoImage = document.getElementById('videoImage');
        videoImageContext = videoImage.getContext('2d');
        videoImageContext.fillStyle = '#cccccc'; // background color if no video present
        videoImageContext.fillRect(0, 0, videoImage.width, videoImage.height);

        videoTexture = new THREE.Texture(videoImage);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
      }

      // create uniforms for the textures
      uniforms.superTileTexture = {type: 't', value: superTileData.textures[0]};
      uniforms.subTileAtlas = {type: 't', value: subTileData.atlas};
      uniforms.subTileAverages = {type: 'fv', value: flatten(subTileData.averages)};
      uniforms.numSubImages = {type: 'i', value: subTileData.textures.length};

      $('#stage').append(renderer.domElement);

      // make the canvas always cover the entire screen
      window.onresize = function() {
        var width = window.innerWidth;
        var height = window.innerHeight;
        var viewingAngle = 70;
        var aspectRatio = width / height;
        var near = 0.1, far = 2000;
        renderer.setSize(width, height);
        $(renderer.domElement).attr('width', width);
        $(renderer.domElement).attr('height', height);
        camera = new THREE.PerspectiveCamera(viewingAngle, aspectRatio, near, far);
        uniforms.resolution.value.set(width, height);

        scene.add(camera);
        camera.position.set(0, 0, 0);
        camera.lookAt(scene.position);
      }
      window.onresize();

      // -- initialize quad --
      var shaderMaterial = new THREE.ShaderMaterial({
        vertexShader: $('#vertexShader').get(0).textContent,
        fragmentShader: $('#fragmentShader').get(0).textContent,
        uniforms: uniforms,
      });
      var planeGeometry = new THREE.PlaneGeometry(50, 50, 50, 50);
      var plane = new THREE.Mesh(planeGeometry, shaderMaterial);
      plane.position.set(0, 0, -1);
      scene.add(plane);

      // -- mouse tracking -- TODO unused at the moment
      $('body').mousemove(function(event) {
        uniforms.mouse.value.set(event.clientX, window.innerHeight - event.clientY /* flip y */);
      });

      // -- begin rendering --
      function render() {
        requestAnimationFrame(render);

        // update the webcam texture when we can
        if (webcamReady && video.readyState === video.HAVE_ENOUGH_DATA) {
          videoImageContext.drawImage(video, 0, 0, videoImage.width, videoImage.height);
          if (videoTexture) {
            videoTexture.needsUpdate = true;
          }
        }

        renderer.render(scene, camera);
        function update() {
          var prevTimeElapsed = uniforms.time.value;
          var timeElapsed = (new Date()) - timeStarted;
          var dt = timeElapsed - prevTimeElapsed;
          var ZOOM_MAX = uniforms.zoomMax.value;

          uniforms.time.value = timeElapsed;
          uniforms.zoom.value = uniforms.zoom.value + dt / 2000;
          if (uniforms.zoom.value > ZOOM_MAX) {
            // reset zoom and switch the sub/super tilesets
            uniforms.zoom.value = uniforms.zoom.value % ZOOM_MAX + 1.0;

            var tmp = superTileData;
            superTileData = subTileData;
            subTileData = tmp;

            // the bottom left pixel's r value encodes the new super tile texture index.
            // we need to retrieve it and modify our uniforms to reflect the change
            var canvas = document.createElement('canvas');
            canvas.width = renderer.domElement.width;
            canvas.height = renderer.domElement.height;
            var context = canvas.getContext('2d');
            context.drawImage(renderer.domElement, 0, 0);
            var pixelData = context.getImageData(0, renderer.domElement.height-1, 1, 1).data;
            var newSuperTileIndex = Math.floor(pixelData[0] / 255 * superTileData.textures.length + 0.5); 

            if (!webcamReady) {
              uniforms.superTileTexture.value = superTileData.textures[newSuperTileIndex];
            }
            else {
              uniforms.superTileTexture.value = videoTexture;
            }
            uniforms.subTileAtlas.value = subTileData.atlas;
            uniforms.subTileAverages.value = flatten(subTileData.averages);

            uniforms.numSubImages.value = subTileData.textures.length;
          }
          var zoomPos = 0;
          uniforms.zoomPosition.value = new THREE.Vector2(zoomPos, zoomPos);
        }
        update();
      }
      render();
    })
  </script>
  <script>
    // -- google image crawler --

    // gets image urls from google images and stores them in stack
    // google.load() needs to first be called before calling this
    var getGISURLS = function(stack, query, numImages, callback) {
      var MAX_IMAGES_PER_PAGE = 8; // api's max results per page is 8
      var gis = google.search.ImageSearch;
      var imageSearch = new google.search.ImageSearch();
      imageSearch.setRestriction(gis.RESTRICT_IMAGESIZE,
                                 gis.IMAGESIZE_MEDIUM);
      imageSearch.setResultSetSize(Math.min(MAX_IMAGES_PER_PAGE, numImages));
      imageSearch.setSearchCompleteCallback(null, function(query, callback) {
        for (var i = 0; 
             stack.length < numImages && i < MAX_IMAGES_PER_PAGE; 
             i++) {
          if (imageSearch.results[i]) {
            // note: .url fetches the image from some website and sometimes
            // redirects to an html page instead of an image...
            // use .tbUrl (low-res version hosted by google) for consistency.
            // TODO: find a way to handle .url weirdness
            stack.push(imageSearch.results[i].tbUrl);
          }
        }

        if (stack.length >= numImages) {
          callback();
        }
        else { // turn page if we have yet to get enough images
          var cursor = imageSearch.cursor;
          if (cursor) {
            var numPagesAvailable = cursor.pages.length;
            console.log('turn pg', cursor.currentPageIndex+1, '/', numPagesAvailable);
            if (cursor.currentPageIndex+1 < numPagesAvailable) {
              imageSearch.gotoPage(cursor.currentPageIndex+1);
            }
            else {
              alert('not enough pages');
            }
          }
          else callback();
        }
      }, [query, callback]);
      imageSearch.execute(query);
    };


    // from http://stackoverflow.com/questions/1403888/get-escaped-url-parameter
    function getURLParameter(name) {
      var ret = decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
      );
      if (ret == 'null') return undefined;
      else return ret;
    }

    // get images
    var useCamera = getURLParameter('useCamera') || false;
    var staticFolder = getURLParameter('staticFolder') || undefined;
    if (staticFolder) {
      var query1 = staticFolder;
      var query2 = staticFolder;
    }
    else {
      var query1 = getURLParameter('q1') || 'space';
      var query2 = getURLParameter('q2') || 'nature';

      if (query1 == 'me' && query2 == 'me') {
        alert('at least one of the fields must be a query');
      }
    }

    $('#query1').val(query1);
    $('#query2').val(query2);
    var queries = [query1, query2];

    // "offline" version. get images from specified directory instead of through node server + google
    if (staticFolder) {
      console.log('using static folder');
      $('#queryEditor').hide();
      var out;
      var successfulReuploads = [];
      for (var i = 0; i < 64; i++) {
        successfulReuploads.push(i);
      }
      out = [successfulReuploads, successfulReuploads];
      $(document).trigger('allImagesReady', [queries, out, useCamera]); 
    }
    else {
      console.log('begin gis search...', queries);
      var downloadStack = [];
      var numImages = 9; // any changes to this need to be reflected in the shader
      var queryStacks = [[], []];
      google.load('search', '1');
      google.setOnLoadCallback(function() {
        getGISURLS(queryStacks[0], queries[0], numImages, function() {
          getGISURLS(queryStacks[1], queries[1], numImages, function() {
            // once we have our urls, send them to the server for rehosting
            var socket = io.connect('/', {reconnect: false});
            socket.emit('reuploadRequest', queries, queryStacks);

            console.log('waiting for reply from server...');
            // once the server tells us it has finished...
            socket.on('reuploadComplete', function(successfulReuploads) {
              $(document).trigger('allImagesReady', [queries, successfulReuploads, useCamera]);
            });
          });
        });
      });
    }
  </script>
</html>
