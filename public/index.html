<html>
  <script src="./jquery-1.11.0.min.js"></script>
  <script src="./three.min.js"></script>
  <script src="socket.io/socket.io.js"></script>
  <script src="https://www.google.com/jsapi"></script>
  <body style="width:100%; height:100%; margin:0px;">
    <!-- dom elements for webcam texture -->
    <video id="monitor" autoplay width="160" height="120" style="visibility:hidden; position:absolute"></video>
    <canvas id="videoImage" width="160" height="120" style="visibility:hidden; position:absolute"></canvas> 

    <div id="stage" hidden width="100%" height="100%"></div>
    <div id="queryEditor" style="padding:0.2em; position:fixed; left:1em; top:1em; background-color:#333333">
      <input type="text" id="query1" placeholder="first query" value="space"><br>
      <input type="text" id="query2" placeholder="second query" value="nature"><br>
      <button id="searchButton">Go</button>
    </div>
    <img id="spinner" src="./spinner.gif" style="background:#ffffff; background-size:100% 100%; position:absolute; left:50%; top:50%;"></img>
  </body>
  </script>
  <script>
    $('#searchButton').click(function() {
      console.log($('#query1').val(), $('#query2').val());
      var q1 = $('#query1').val(), q2 = $('#query2').val();
      if (q1.length > 0 && q2.length > 0) {
        window.location = '?q1=' + q1 + '&q2=' + q2;
      }
    });

    $('#query1').on('input', function() {
      if ($('#query1').val().length == 0) {
        $('#searchButton').attr('disabled', 'disabled');
      }
      else if ($('#query2').val().length > 0) {
        $('#searchButton').removeAttr('disabled');
      }
    });
    $('#query2').on('input', function() {
      if ($('#query2').val().length == 0) {
        $('#searchButton').attr('disabled', 'disabled');
      }
      else if ($('#query1').val().length > 0) {
        $('#searchButton').removeAttr('disabled');
      }
    });

    function flatten(arr) {
      return arr.reduce(function(a, b) {
        return a.concat(b);
      });
    }

    // start the mosaic once the reuploaded images are ready
    $(document).on('allImagesReady', function(e, queries, successfulReuploads, useCamera) {
      for (var i = 0; i < queries.length; i++) {
        if (successfulReuploads[i].length == 0) {
          alert('Not enough images were found for query "' + queries[i] + '"');
          return;
        }
      }

      console.log('starting mosaic', queries, successfulReuploads);
      // -- graphics code --
      // -- set up --
      try {
        var scene = new THREE.Scene();
        var camera = undefined; 
        var renderer = new THREE.WebGLRenderer({antialias: true});
        // webcam vars
        var video, videoTexture, videoImage, videoImageContext, webcamReady = false;
      } catch(e) {
        alert('There was a problem creating the webgl context.');
      }
      var timeStarted = new Date();

      function TileData() {
        this.textures = [];
        this.averages = [];
        this.atlas = undefined; // one big texture containing all textures
      }
      var superTileData = new TileData();
      var subTileData = new TileData();
      var ATLAS_WIDTH = 8192, ATLAS_HEIGHT = 8192;
      var ATLAS_SUB_WIDTH = 512, ATLAS_SUB_HEIGHT = 512;

      // -- initialize basic uniforms --
      var uniforms = {
          time: {type: 'f', value: 0},
          mouse: {type: 'v2', value: new THREE.Vector2(0, 0)},
          resolution: {type: 'v2', value: new THREE.Vector2(0, 0)},

          zoom: {type: 'f', value: 1},
          zoomMax: {type: 'f', value: 2.7}, 
          zoomPosition: {type: 'v2', value: new THREE.Vector2(0, 0)},
      };

      // placeholder values until we calculate actual averages
      for (var i = 0; i < successfulReuploads[0].length; i++) {
        superTileData.averages.push([0.5, 0.5, 0.5]);
      }
      for (var i = 0; i < successfulReuploads[1].length; i++) {
        subTileData.averages.push([0.5, 0.5, 0.5]);
      }

      // load the reuploaded images and calculate average color
      var imagesLeft = 0; // number of images we have left to load
      for (var queryIndex = 0; queryIndex < queries.length; queryIndex++) {
        imagesLeft += successfulReuploads[queryIndex].length;
      }

      for (var queryIndex = 0; queryIndex < queries.length; queryIndex++) {
        var query = queries[queryIndex];

        // load images
        for (var i = 0; i < successfulReuploads[queryIndex].length; i++) {
          var textureIndex = successfulReuploads[queryIndex][i];
          var url = 'reup/' + query + '/' + textureIndex;
          // get texture (async)
          (function(qi) {
            new THREE.ImageUtils.loadTexture(url, undefined, 
              function(tex) { // on loaded: 
                tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                if (qi == 0) {
                  superTileData.textures.push(tex);
                }
                else if (qi == 1) {
                  subTileData.textures.push(tex);
                }

                imagesLeft--;
                if (imagesLeft == 0) {
                  preprocessTiles([superTileData, subTileData]);
                }
              }, function() { // on error
                imagesLeft--;
                if (imagesLeft == 0) {
                  preprocessTiles([superTileData, subTileData]);
                }
              }
            );
          })(queryIndex);
        }
      } 

      function preprocessTiles(tileDatas) {
        function getAverageRGB(texture) {
          var average = [0.5, 0.5, 0.5];
          var canvas = document.createElement('canvas');
          var context = canvas.getContext('2d');
          var data = undefined;
          var blockSize = 5; // sample every X pixels
          var count = 0;

          canvas.width = texture.image.width;
          canvas.height = texture.image.height;
          context.drawImage(texture.image, 0, 0);
          data = context.getImageData(0, 0, canvas.width, canvas.height);

          for (var i = 0; (i + blockSize * 4) < data.data.length; i += blockSize * 4) {
            average[0] += data.data[i];
            average[1] += data.data[i+1];
            average[2] += data.data[i+2];
            count++;
          }

          average[0] = Math.floor(average[0] / count) / 255.0;
          average[1] = Math.floor(average[1] / count) / 255.0;
          average[2] = Math.floor(average[2] / count) / 255.0;

          return average;
        }

        function generateAtlas(textures, atlasWidth, atlasHeight, subWidth, subHeight) {
          var tilesPerRow = Math.floor(atlasWidth / subWidth);
          var tilesPerColumn = Math.floor(atlasWidth / subHeight);
          if (atlasWidth % subWidth != 0 || atlasHeight % subHeight != 0) {
            console.warn('Atlas size does not evenly divide into subsize');
          }
          if (textures.length > tilesPerRow * tilesPerColumn) {
            throw new Error('Atlas is too small to hold the given textures');
          }

          var canvas = document.createElement('canvas');
          var context = canvas.getContext('2d');
          canvas.width = atlasHeight; 
          canvas.height = atlasWidth;

          for (var i = 0; i < textures.length; i++) {
            var tileX = (i * subWidth) % atlasWidth;
            var tileY = Math.floor((i * subWidth) / atlasWidth) * subHeight;
            context.drawImage(textures[i].image, tileX, tileY, subWidth, subHeight);
          }

          document.body.appendChild(canvas);

          var ret = new THREE.Texture(canvas);
          ret.wrapS = ret.wrapT = THREE.RepeatWrapping;
          return ret;
        }

        for (var tileDataIndex = 0; tileDataIndex < tileDatas.length; tileDataIndex++) {
          var tileData = tileDatas[tileDataIndex];
          for (var i = 0; i < tileData.textures.length; i++) {
            tileData.averages[i] = getAverageRGB(tileData.textures[i]);
          }
          tileData.atlas = generateAtlas(tileData.textures, ATLAS_WIDTH, ATLAS_HEIGHT, ATLAS_SUB_WIDTH, ATLAS_SUB_HEIGHT);
          tileData.atlas.needsUpdate = true;
        }
        $('#spinner').hide();
        $('#stage').show();
        uniforms.superTileTexture.value = superTileData.textures[0];
        uniforms.subTileAtlas.value = subTileData.atlas;
        uniforms.subTileAverages.value = flatten(subTileData.averages);
        uniforms.numSubImages.value = subTileData.textures.length;

      }

      // begin webcam code
      // bits of code here from http://stemkoski.github.io/Three.js/Webcam-Texture.html
      if (useCamera) {
        // initialize camera
        navigator.getUserMedia = navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        window.URL = window.URL || window.webkitURL;

        var camVideo = $('#monitor')[0];
        if (!navigator.getUserMedia) {
          alert('Your browser does not have webcam support');
        }
        else {
          navigator.getUserMedia({video: true}, 
          function(stream) { // on success (user clicks 'allow')
            if (window.URL) {
              camVideo.src = window.URL.createObjectURL(stream);
            }
            else { // Opera
              camVideo.src = stream;
            }
            camVideo.onerror = function(error) {
              stream.stop();
            }
            webcamReady = true;
          },
          function(error) { // on failure
            alert('webcam error:', error);
          });
        }

        // get cam texture
        video = document.getElementById('monitor');
    
        videoImage = document.getElementById('videoImage');
        videoImageContext = videoImage.getContext('2d');
        videoImageContext.fillStyle = '#cccccc'; // background color if no video present
        videoImageContext.fillRect(0, 0, videoImage.width, videoImage.height);

        videoTexture = new THREE.Texture(videoImage);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
      }

      // create uniforms for the textures
      uniforms.superTileTexture = {type: 't', value: superTileData.textures[0]};
      uniforms.subTileAtlas = {type: 't', value: subTileData.atlas};
      uniforms.subTileAverages = {type: 'fv', value: flatten(subTileData.averages)};
      uniforms.numSubImages = {type: 'i', value: subTileData.textures.length};

      $('#stage').append(renderer.domElement);

      // make the canvas always cover the entire screen
      window.onresize = function() {
        var width = window.innerWidth;
        var height = window.innerHeight;
        var viewingAngle = 70;
        var aspectRatio = width / height;
        var near = 0.1, far = 2000;
        renderer.setSize(width, height);
        $(renderer.domElement).attr('width', width);
        $(renderer.domElement).attr('height', height);
        camera = new THREE.PerspectiveCamera(viewingAngle, aspectRatio, near, far);
        uniforms.resolution.value.set(width, height);

        scene.add(camera);
        camera.position.set(0, 0, 0);
        camera.lookAt(scene.position);
      }
      window.onresize();

      // -- initialize quad --
      // read external shader source text
      function getShaderSource(url) {
        var req = new XMLHttpRequest();
        req.open('GET', url, false);
        req.send(null);
        if (req.status == 200) {
          return req.responseText;
        }
        else return undefined;
      }
      var shaderMaterial = new THREE.ShaderMaterial({
        vertexShader: getShaderSource('vertex.glsl'), 
        fragmentShader: getShaderSource('fragment.glsl'), 
        uniforms: uniforms,
      });
      var planeGeometry = new THREE.PlaneGeometry(50, 50, 50, 50);
      var plane = new THREE.Mesh(planeGeometry, shaderMaterial);
      plane.position.set(0, 0, -1);
      scene.add(plane);

      // -- mouse tracking -- TODO unused at the moment
      $('body').mousemove(function(event) {
        uniforms.mouse.value.set(event.clientX, window.innerHeight - event.clientY /* flip y */);
      });

      // -- begin rendering --
      function render() {
        requestAnimationFrame(render);

        // update the webcam texture when we can
        if (webcamReady && video.readyState === video.HAVE_ENOUGH_DATA) {
          videoImageContext.drawImage(video, 0, 0, videoImage.width, videoImage.height);
          if (videoTexture) {
            videoTexture.needsUpdate = true;
          }
        }

        renderer.render(scene, camera);
        function update() {
          var prevTimeElapsed = uniforms.time.value;
          var timeElapsed = (new Date()) - timeStarted;
          var dt = timeElapsed - prevTimeElapsed;
          var ZOOM_MAX = uniforms.zoomMax.value;

          uniforms.time.value = timeElapsed;
          uniforms.zoom.value = uniforms.zoom.value + dt / 2000;
          if (uniforms.zoom.value > ZOOM_MAX) {
            // reset zoom and switch the sub/super tilesets
            uniforms.zoom.value = uniforms.zoom.value % ZOOM_MAX + 1.0;

            var tmp = superTileData;
            superTileData = subTileData;
            subTileData = tmp;

            // the bottom left pixel's r value encodes the new super tile texture index.
            // we need to retrieve it and modify our uniforms to reflect the change
            var canvas = document.createElement('canvas');
            canvas.width = renderer.domElement.width;
            canvas.height = renderer.domElement.height;
            var context = canvas.getContext('2d');
            context.drawImage(renderer.domElement, 0, 0);
            var pixelData = context.getImageData(0, renderer.domElement.height-1, 1, 1).data;
            var newSuperTileIndex = Math.floor(pixelData[0] / 255 * superTileData.textures.length + 0.5); 

            if (!webcamReady) {
              uniforms.superTileTexture.value = superTileData.textures[newSuperTileIndex];
            }
            else {
              uniforms.superTileTexture.value = videoTexture;
            }
            uniforms.subTileAtlas.value = subTileData.atlas;
            uniforms.subTileAverages.value = flatten(subTileData.averages);

            uniforms.numSubImages.value = subTileData.textures.length;
          }
          var zoomPos = 0;
          uniforms.zoomPosition.value = new THREE.Vector2(zoomPos, zoomPos);
        }
        update();
      }
      render();
    })
  </script>
  <script>
    // -- google image crawler --

    // gets image urls from google images and stores them in stack
    // google.load() needs to first be called before calling this
    var getGISURLS = function(stack, query, numImages, callback) {
      var MAX_IMAGES_PER_PAGE = 8; // api's max results per page is 8
      var gis = google.search.ImageSearch;
      var imageSearch = new google.search.ImageSearch();
      imageSearch.setRestriction(gis.RESTRICT_IMAGESIZE,
                                 gis.IMAGESIZE_MEDIUM);
      imageSearch.setResultSetSize(Math.min(MAX_IMAGES_PER_PAGE, numImages));
      imageSearch.setSearchCompleteCallback(null, function(query, callback) {
        for (var i = 0; 
             stack.length < numImages && i < MAX_IMAGES_PER_PAGE; 
             i++) {
          if (imageSearch.results[i]) {
            // note: .url fetches the image from some website and sometimes
            // redirects to an html page instead of an image...
            // use .tbUrl (low-res version hosted by google) for consistency.
            // TODO: find a way to handle .url weirdness
            stack.push(imageSearch.results[i].tbUrl);
          }
        }

        if (stack.length >= numImages) {
          callback();
        }
        else { // turn page if we have yet to get enough images
          var cursor = imageSearch.cursor;
          if (cursor) {
            var numPagesAvailable = cursor.pages.length;
            console.log('turn pg', cursor.currentPageIndex+1, '/', numPagesAvailable);
            if (cursor.currentPageIndex+1 < numPagesAvailable) {
              imageSearch.gotoPage(cursor.currentPageIndex+1);
            }
            else {
              alert('not enough pages');
            }
          }
          else callback();
        }
      }, [query, callback]);
      imageSearch.execute(query);
    };


    // from http://stackoverflow.com/questions/1403888/get-escaped-url-parameter
    function getURLParameter(name) {
      var ret = decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
      );
      if (ret == 'null') return undefined;
      else return ret;
    }

    // get images
    var useCamera = getURLParameter('useCamera') || false;
    var staticFolder = getURLParameter('staticFolder') || undefined;
    if (staticFolder) {
      var query1 = staticFolder;
      var query2 = staticFolder;
    }
    else {
      var query1 = getURLParameter('q1') || 'space';
      var query2 = getURLParameter('q2') || 'nature';
    }

    $('#query1').val(query1);
    $('#query2').val(query2);
    var queries = [query1, query2];

    // "offline" version. get images from specified directory instead of through node server + google
    if (staticFolder) {
      console.log('using static folder');
      $('#queryEditor').hide();
      var out;
      var successfulReuploads = [];
      var MAX_STATIC_FOLDER_IMAGES = 256;
      for (var i = 0; i < MAX_STATIC_FOLDER_IMAGES; i++) {
        // assume there are MAX_STATIC_FOLDER_IMAGES in any given folder. 
        // any missing images will be dealt with later
        successfulReuploads.push(i);
      }
      out = [successfulReuploads, successfulReuploads];
      $(document).trigger('allImagesReady', [queries, out, useCamera]); 
    }
    else {
      console.log('begin gis search...', queries);
      var downloadStack = [];
      var numImages = 9; // any changes to this need to be reflected in the shader
      var queryStacks = [[], []];
      google.load('search', '1');
      google.setOnLoadCallback(function() {
        getGISURLS(queryStacks[0], queries[0], numImages, function() {
          getGISURLS(queryStacks[1], queries[1], numImages, function() {
            // once we have our urls, send them to the server for rehosting
            var socket = io.connect('/', {reconnect: false});
            socket.emit('reuploadRequest', queries, queryStacks);

            console.log('waiting for reply from server...');
            // once the server tells us it has finished...
            socket.on('reuploadComplete', function(successfulReuploads) {
              $(document).trigger('allImagesReady', [queries, successfulReuploads, useCamera]);
            });
          });
        });
      });
    }
  </script>
</html>
